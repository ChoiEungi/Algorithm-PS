# 개념 짚고 넘어가기
- 큰 문제를 작은 문제롤 나눌 수 있고, 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일 -> dynamic programming 사용
- Memoization 기법: 다이나믹 프로그래밍 구현 방법 중 한 종류로, 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식이 다시 호출되면 메모한 결과를 그대로 가져오는 기법 (메모이제이션을 chaching이라고도 함, DP의 Top-Down 방식에 국한되는 표현)

- Divide and Qonquer vs DP : 큰 문제를 작게 나눔 but DP는 문제들이 서로 영향을 미침
- 재귀함수 사용 시 함수를 다시 호출했을 때 메모리 상에 적재됨 -> 반복문 사용하여 오버헤드 줄일 수 있음(반복문을 이용한 DP이 더 성능이 좋음)
- 재귀 함수를 이용하여 DP 작성(큰 문제를 해결하기 위해 작은 문제를 호출) : **Top-Down 방식**(시스템상 재귀 함수의 스택 크기 한정되어 있을 수 있음)
단순히 반복문을 이용하여 DP 작성(작은 문제부터 차근차근 답을 도출) : **Bottom-Up 방식**(전형적인 DP 형태)
- an을 계산하고자 할 때 a0~an-1 모두가 아닌 일부의 작은 문제에 대한 해답만 필요한 경우 -> dic 자료형 이용하여 메모이제이션
- 완전 탐색 알고리즘으로 접근시 시간이 오래 걸릴 때 -> 해결하고자 하는 부분 문제들의 중복 여부 확인 -> DP 적용 여부 결정
- sys.setrecursionlimit() : 재귀 제한(like recursion depth) 완화



